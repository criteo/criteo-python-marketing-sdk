# coding: utf-8

"""
    Marketing API v.1.0

    IMPORTANT: This swagger links to Criteo production environment. Any test applied here will thus impact real campaigns.  # noqa: E501

    OpenAPI spec version: v.1.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from criteo_marketing.api_client import ApiClient


class SellersV2StatsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def campaigns(self, authorization, **kwargs):  # noqa: E501
        """Get stats by campaign.  # noqa: E501

        ## Dimensions                Get performance statistics aggregated for _campaigns_. The campaign id appears  in the output as the first column.                Aggregation can be done by `hour`, `day`, `month`, or `year`. The aggregation  interval size is controlled by `intervalSize`. The time interval appears in  the output as the second column.                ## Metrics                The metrics reported by this endpoint are                .  | Metric Group | Description  ---|--------------|------------  A | impressions | Number of times product is shown in a banner  B | clicks | Number of clicks on product  C | cost | Amount spent for clicks on products  D | saleUnits | Number of products sold attributed to clicks  E | revenue | Revenue generated by sales  F | CR = Conversion Rate | salesUnits / clicks  G | CPO = Cost Per Order | cost / salesUnits  H | COS = Cost of Sale | cost / revenue  I | ROAS = Return On Add Spend | revenue / cost                The last six metrics can be computed in two ways depending on the policy to count only  the sales that result from clicks on the same sellers product in a banner  (same-seller) or not (any-seller).  Reporting can be controlled by `clickAttributionPolicy`.                The 9 (or 15) metric values appear in the output as the final 9 (or 15) columns.                ## Filtering                The results can be filtered by date or count.                Filtering the results to events  that happened in a time interval is done by setting the `startDate` and  `endDate` filter parameters using the `yyyy-MM-DD` format. The start date  includes all events timestamped since the beginning of that day while the end  date includes events until the end of day. The maximum duration of the date  range is 1 year. If the aggregation interval is `hour`, then the maximum  duration of the date range is 1 month. Note that month and year aggregate values  may contain partial data for the interval if filtering by date.                Filtering the results to a maximum number of data rows is done by setting the  `count` filter parameter. When combined with startDate this can be used to perform  simple pagination.                ## Response Format                The representation format can be specified by MIME values in the Accept header.  For now the only supported values for the accept header is `application/json` and  `text/csv`.                ```json  {  \"columns\":[\"campaignId\", \"sellerId\", \"interval\", \"impressions\", \"clicks\", \"cost\", \"salesUnits\", \"revenue\", …],  \"data\":  [[\"2099873\",    \"321224\",   \"2018-01\",  2345,          128,      64.23,  9,            287.32,    …],            [\"2099873\",    \"321224\",   \"2018-02\",  1129,          98,       44.93,  6,            171.80,    …],            [\"2099873\",    \"321224\",   \"2018-03\",  3476,          322,      15.27,  18,           587.37,    …],            …           ],  \"rows\":  1600  }  ```                The JSON result is an object with three fields (`columns`, `data`, and `rows`). The  “columns” array acts as the header for the data rows. The categorical dimension  columns come first and will vary with the endpoint used (campaignId and/or  sellerId and interval). The interval column comes next. The interval size is  determined by the intervalSize parameter. This is followed by either nine or  fifteen metrics columns. The first three metrics (impressions, clicks, and cost)  always appear. The remaining depend on the clickAttributionPolicy parameter.                The “data” array contains data rows whose values match the entries in the  “columns” array. The dimensions are always strings. The metrics are JSON objects  whose type is number. Some of these are natural numbers (e.g. clicks and  impressions) whereas others are decimal values. As mentioned earlier the  currency is assumed to be the local currency established by the advertiser.                The “row” value is a count of the number of rows in the data array, and can be  used to check the integrity of the data.                Further information on the campaign or seller (e.g. the seller name) can be  obtained from the existing V1 or V2 endpoints using the campaign and/or seller  ID values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.campaigns(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: JWT Bearer Token (required)
        :param str interval_size: Specify the aggregation interval for events used to compute stats (default is \"day\")
        :param str click_attribution_policy: Specify the click attribution policy for salesUnits, revenue, CR, CPO, COS, and ROAS
        :param datetime start_date: Filter out all events that occur before date (default is the value of `endDate`)
        :param datetime end_date: Filter out all events that occur after date (default is today’s date)
        :param int count: Return up to the first count rows of data (default is to return all rows available)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.campaigns_with_http_info(authorization, **kwargs)  # noqa: E501
        else:
            (data) = self.campaigns_with_http_info(authorization, **kwargs)  # noqa: E501
            return data

    def campaigns_with_http_info(self, authorization, **kwargs):  # noqa: E501
        """Get stats by campaign.  # noqa: E501

        ## Dimensions                Get performance statistics aggregated for _campaigns_. The campaign id appears  in the output as the first column.                Aggregation can be done by `hour`, `day`, `month`, or `year`. The aggregation  interval size is controlled by `intervalSize`. The time interval appears in  the output as the second column.                ## Metrics                The metrics reported by this endpoint are                .  | Metric Group | Description  ---|--------------|------------  A | impressions | Number of times product is shown in a banner  B | clicks | Number of clicks on product  C | cost | Amount spent for clicks on products  D | saleUnits | Number of products sold attributed to clicks  E | revenue | Revenue generated by sales  F | CR = Conversion Rate | salesUnits / clicks  G | CPO = Cost Per Order | cost / salesUnits  H | COS = Cost of Sale | cost / revenue  I | ROAS = Return On Add Spend | revenue / cost                The last six metrics can be computed in two ways depending on the policy to count only  the sales that result from clicks on the same sellers product in a banner  (same-seller) or not (any-seller).  Reporting can be controlled by `clickAttributionPolicy`.                The 9 (or 15) metric values appear in the output as the final 9 (or 15) columns.                ## Filtering                The results can be filtered by date or count.                Filtering the results to events  that happened in a time interval is done by setting the `startDate` and  `endDate` filter parameters using the `yyyy-MM-DD` format. The start date  includes all events timestamped since the beginning of that day while the end  date includes events until the end of day. The maximum duration of the date  range is 1 year. If the aggregation interval is `hour`, then the maximum  duration of the date range is 1 month. Note that month and year aggregate values  may contain partial data for the interval if filtering by date.                Filtering the results to a maximum number of data rows is done by setting the  `count` filter parameter. When combined with startDate this can be used to perform  simple pagination.                ## Response Format                The representation format can be specified by MIME values in the Accept header.  For now the only supported values for the accept header is `application/json` and  `text/csv`.                ```json  {  \"columns\":[\"campaignId\", \"sellerId\", \"interval\", \"impressions\", \"clicks\", \"cost\", \"salesUnits\", \"revenue\", …],  \"data\":  [[\"2099873\",    \"321224\",   \"2018-01\",  2345,          128,      64.23,  9,            287.32,    …],            [\"2099873\",    \"321224\",   \"2018-02\",  1129,          98,       44.93,  6,            171.80,    …],            [\"2099873\",    \"321224\",   \"2018-03\",  3476,          322,      15.27,  18,           587.37,    …],            …           ],  \"rows\":  1600  }  ```                The JSON result is an object with three fields (`columns`, `data`, and `rows`). The  “columns” array acts as the header for the data rows. The categorical dimension  columns come first and will vary with the endpoint used (campaignId and/or  sellerId and interval). The interval column comes next. The interval size is  determined by the intervalSize parameter. This is followed by either nine or  fifteen metrics columns. The first three metrics (impressions, clicks, and cost)  always appear. The remaining depend on the clickAttributionPolicy parameter.                The “data” array contains data rows whose values match the entries in the  “columns” array. The dimensions are always strings. The metrics are JSON objects  whose type is number. Some of these are natural numbers (e.g. clicks and  impressions) whereas others are decimal values. As mentioned earlier the  currency is assumed to be the local currency established by the advertiser.                The “row” value is a count of the number of rows in the data array, and can be  used to check the integrity of the data.                Further information on the campaign or seller (e.g. the seller name) can be  obtained from the existing V1 or V2 endpoints using the campaign and/or seller  ID values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.campaigns_with_http_info(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: JWT Bearer Token (required)
        :param str interval_size: Specify the aggregation interval for events used to compute stats (default is \"day\")
        :param str click_attribution_policy: Specify the click attribution policy for salesUnits, revenue, CR, CPO, COS, and ROAS
        :param datetime start_date: Filter out all events that occur before date (default is the value of `endDate`)
        :param datetime end_date: Filter out all events that occur after date (default is today’s date)
        :param int count: Return up to the first count rows of data (default is to return all rows available)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization', 'interval_size', 'click_attribution_policy', 'start_date', 'end_date', 'count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method campaigns" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ValueError("Missing the required parameter `authorization` when calling `campaigns`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'interval_size' in local_var_params:
            query_params.append(('intervalSize', local_var_params['interval_size']))  # noqa: E501
        if 'click_attribution_policy' in local_var_params:
            query_params.append(('clickAttributionPolicy', local_var_params['click_attribution_policy']))  # noqa: E501
        if 'start_date' in local_var_params:
            query_params.append(('startDate', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params:
            query_params.append(('endDate', local_var_params['end_date']))  # noqa: E501
        if 'count' in local_var_params:
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/stats/campaigns', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def seller_campaigns(self, authorization, **kwargs):  # noqa: E501
        """Get stats by seller-campaign.  # noqa: E501

        ## Dimensions                Get performance statistics aggregated for _seller campaigns_.                Aggregation can be done by `hour`, `day`, `month`, or `year`. The aggregation  interval size is controlled by `intervalSize`. The time interval appears in  the output as the second column.                ## Metrics                The metrics reported by this endpoint are                .  | Metric Group | Description  ---|--------------|------------  A | impressions | Number of times product is shown in a banner  B | clicks | Number of clicks on product  C | cost | Amount spent for clicks on products  D | saleUnits | Number of products sold attributed to clicks  E | revenue | Revenue generated by sales  F | CR = Conversion Rate | salesUnits / clicks  G | CPO = Cost Per Order | cost / salesUnits  H | COS = Cost of Sale | cost / revenue  I | ROAS = Return On Add Spend | revenue / cost                The last six metrics can be computed in two ways depending on the policy to count only  the sales that result from clicks on the same sellers product in a banner  (same-seller) or not (any-seller).  Reporting can be controlled by `clickAttributionPolicy`.                The 9 (or 15) metric values appear in the output as the final 9 (or 15) columns.                ## Filtering                The results can be filtered by date or count.                Filtering the results to events  that happened in a time interval is done by setting the `startDate` and  `endDate` filter parameters using the `yyyy-MM-DD` format. The start date  includes all events timestamped since the beginning of that day while the end  date includes events until the end of day. The maximum duration of the date  range is 1 year. If the aggregation interval is `hour`, then the maximum  duration of the date range is 1 month. Note that month and year aggregate values  may contain partial data for the interval if filtering by date.                Filtering the results to a maximum number of data rows is done by setting the  `count` filter parameter. When combined with startDate this can be used to perform  simple pagination.                ## Response Format                The representation format can be specified by MIME values in the Accept header.  For now the only supported values for the accept header is `application/json` and  `text/csv`.                ```json  {  \"columns\":[\"campaignId\", \"sellerId\", \"interval\", \"impressions\", \"clicks\", \"cost\", \"salesUnits\", \"revenue\", …],  \"data\":  [[\"2099873\",    \"321224\",   \"2018-01\",  2345,          128,      64.23,  9,            287.32,    …],            [\"2099873\",    \"321224\",   \"2018-02\",  1129,          98,       44.93,  6,            171.80,    …],            [\"2099873\",    \"321224\",   \"2018-03\",  3476,          322,      15.27,  18,           587.37,    …],            …           ],  \"rows\":  1600  }  ```                The JSON result is an object with three fields (`columns`, `data`, and `rows`). The  “columns” array acts as the header for the data rows. The categorical dimension  columns come first and will vary with the endpoint used (campaignId and/or  sellerId and interval). The interval column comes next. The interval size is  determined by the intervalSize parameter. This is followed by either nine or  fifteen metrics columns. The first three metrics (impressions, clicks, and cost)  always appear. The remaining depend on the clickAttributionPolicy parameter.                The “data” array contains data rows whose values match the entries in the  “columns” array. The dimensions are always strings. The metrics are JSON objects  whose type is number. Some of these are natural numbers (e.g. clicks and  impressions) whereas others are decimal values. As mentioned earlier the  currency is assumed to be the local currency established by the advertiser.                The “row” value is a count of the number of rows in the data array, and can be  used to check the integrity of the data.                Further information on the campaign or seller (e.g. the seller name) can be  obtained from the existing V1 or V2 endpoints using the campaign and/or seller  ID values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.seller_campaigns(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: JWT Bearer Token (required)
        :param str interval_size: Specify the aggregation interval for events used to compute stats (default is \"day\")
        :param str click_attribution_policy: Specify the click attribution policy for salesUnits, revenue, CR, CPO, COS, and ROAS
        :param datetime start_date: Filter out all events that occur before date (default is the value of `endDate`)
        :param datetime end_date: Filter out all events that occur after date (default is today’s date)
        :param int count: Return up to the first count rows of data (default is to return all rows available)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.seller_campaigns_with_http_info(authorization, **kwargs)  # noqa: E501
        else:
            (data) = self.seller_campaigns_with_http_info(authorization, **kwargs)  # noqa: E501
            return data

    def seller_campaigns_with_http_info(self, authorization, **kwargs):  # noqa: E501
        """Get stats by seller-campaign.  # noqa: E501

        ## Dimensions                Get performance statistics aggregated for _seller campaigns_.                Aggregation can be done by `hour`, `day`, `month`, or `year`. The aggregation  interval size is controlled by `intervalSize`. The time interval appears in  the output as the second column.                ## Metrics                The metrics reported by this endpoint are                .  | Metric Group | Description  ---|--------------|------------  A | impressions | Number of times product is shown in a banner  B | clicks | Number of clicks on product  C | cost | Amount spent for clicks on products  D | saleUnits | Number of products sold attributed to clicks  E | revenue | Revenue generated by sales  F | CR = Conversion Rate | salesUnits / clicks  G | CPO = Cost Per Order | cost / salesUnits  H | COS = Cost of Sale | cost / revenue  I | ROAS = Return On Add Spend | revenue / cost                The last six metrics can be computed in two ways depending on the policy to count only  the sales that result from clicks on the same sellers product in a banner  (same-seller) or not (any-seller).  Reporting can be controlled by `clickAttributionPolicy`.                The 9 (or 15) metric values appear in the output as the final 9 (or 15) columns.                ## Filtering                The results can be filtered by date or count.                Filtering the results to events  that happened in a time interval is done by setting the `startDate` and  `endDate` filter parameters using the `yyyy-MM-DD` format. The start date  includes all events timestamped since the beginning of that day while the end  date includes events until the end of day. The maximum duration of the date  range is 1 year. If the aggregation interval is `hour`, then the maximum  duration of the date range is 1 month. Note that month and year aggregate values  may contain partial data for the interval if filtering by date.                Filtering the results to a maximum number of data rows is done by setting the  `count` filter parameter. When combined with startDate this can be used to perform  simple pagination.                ## Response Format                The representation format can be specified by MIME values in the Accept header.  For now the only supported values for the accept header is `application/json` and  `text/csv`.                ```json  {  \"columns\":[\"campaignId\", \"sellerId\", \"interval\", \"impressions\", \"clicks\", \"cost\", \"salesUnits\", \"revenue\", …],  \"data\":  [[\"2099873\",    \"321224\",   \"2018-01\",  2345,          128,      64.23,  9,            287.32,    …],            [\"2099873\",    \"321224\",   \"2018-02\",  1129,          98,       44.93,  6,            171.80,    …],            [\"2099873\",    \"321224\",   \"2018-03\",  3476,          322,      15.27,  18,           587.37,    …],            …           ],  \"rows\":  1600  }  ```                The JSON result is an object with three fields (`columns`, `data`, and `rows`). The  “columns” array acts as the header for the data rows. The categorical dimension  columns come first and will vary with the endpoint used (campaignId and/or  sellerId and interval). The interval column comes next. The interval size is  determined by the intervalSize parameter. This is followed by either nine or  fifteen metrics columns. The first three metrics (impressions, clicks, and cost)  always appear. The remaining depend on the clickAttributionPolicy parameter.                The “data” array contains data rows whose values match the entries in the  “columns” array. The dimensions are always strings. The metrics are JSON objects  whose type is number. Some of these are natural numbers (e.g. clicks and  impressions) whereas others are decimal values. As mentioned earlier the  currency is assumed to be the local currency established by the advertiser.                The “row” value is a count of the number of rows in the data array, and can be  used to check the integrity of the data.                Further information on the campaign or seller (e.g. the seller name) can be  obtained from the existing V1 or V2 endpoints using the campaign and/or seller  ID values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.seller_campaigns_with_http_info(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: JWT Bearer Token (required)
        :param str interval_size: Specify the aggregation interval for events used to compute stats (default is \"day\")
        :param str click_attribution_policy: Specify the click attribution policy for salesUnits, revenue, CR, CPO, COS, and ROAS
        :param datetime start_date: Filter out all events that occur before date (default is the value of `endDate`)
        :param datetime end_date: Filter out all events that occur after date (default is today’s date)
        :param int count: Return up to the first count rows of data (default is to return all rows available)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization', 'interval_size', 'click_attribution_policy', 'start_date', 'end_date', 'count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method seller_campaigns" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ValueError("Missing the required parameter `authorization` when calling `seller_campaigns`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'interval_size' in local_var_params:
            query_params.append(('intervalSize', local_var_params['interval_size']))  # noqa: E501
        if 'click_attribution_policy' in local_var_params:
            query_params.append(('clickAttributionPolicy', local_var_params['click_attribution_policy']))  # noqa: E501
        if 'start_date' in local_var_params:
            query_params.append(('startDate', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params:
            query_params.append(('endDate', local_var_params['end_date']))  # noqa: E501
        if 'count' in local_var_params:
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/stats/seller-campaigns', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def sellers(self, authorization, **kwargs):  # noqa: E501
        """Get stats by seller.  # noqa: E501

        ## Dimensions                Get performance statistics aggregated for _sellers_. The seller id appears  in the output as the first column.                Aggregation can be done by `hour`, `day`, `month`, or `year`. The aggregation  interval size is controlled by `intervalSize`. The time interval appears in  the output as the second column.                ## Metrics                The metrics reported by this endpoint are                .  | Metric Group | Description  ---|--------------|------------  A | impressions | Number of times product is shown in a banner  B | clicks | Number of clicks on product  C | cost | Amount spent for clicks on products  D | saleUnits | Number of products sold attributed to clicks  E | revenue | Revenue generated by sales  F | CR = Conversion Rate | salesUnits / clicks  G | CPO = Cost Per Order | cost / salesUnits  H | COS = Cost of Sale | cost / revenue  I | ROAS = Return On Add Spend | revenue / cost                The last six metrics can be computed in two ways depending on the policy to count only  the sales that result from clicks on the same sellers product in a banner  (same-seller) or not (any-seller).  Reporting can be controlled by `clickAttributionPolicy`.                The 9 (or 15) metric values appear in the output as the final 9 (or 15) columns.                ## Filtering                The results can be filtered by date or count.                Filtering the results to events  that happened in a time interval is done by setting the `startDate` and  `endDate` filter parameters using the `yyyy-MM-DD` format. The start date  includes all events timestamped since the beginning of that day while the end  date includes events until the end of day. The maximum duration of the date  range is 1 year. If the aggregation interval is `hour`, then the maximum  duration of the date range is 1 month. Note that month and year aggregate values  may contain partial data for the interval if filtering by date.                Filtering the results to a maximum number of data rows is done by setting the  `count` filter parameter. When combined with startDate this can be used to perform  simple pagination.                ## Response Format                The representation format can be specified by MIME values in the Accept header.  For now the only supported values for the accept header is `application/json` and  `text/csv`.                ```json  {  \"columns\":[\"campaignId\", \"sellerId\", \"interval\", \"impressions\", \"clicks\", \"cost\", \"salesUnits\", \"revenue\", …],  \"data\":  [[\"2099873\",    \"321224\",   \"2018-01\",  2345,          128,      64.23,  9,            287.32,    …],            [\"2099873\",    \"321224\",   \"2018-02\",  1129,          98,       44.93,  6,            171.80,    …],            [\"2099873\",    \"321224\",   \"2018-03\",  3476,          322,      15.27,  18,           587.37,    …],            …           ],  \"rows\":  1600  }  ```                The JSON result is an object with three fields (`columns`, `data`, and `rows`). The  “columns” array acts as the header for the data rows. The categorical dimension  columns come first and will vary with the endpoint used (campaignId and/or  sellerId and interval). The interval column comes next. The interval size is  determined by the intervalSize parameter. This is followed by either nine or  fifteen metrics columns. The first three metrics (impressions, clicks, and cost)  always appear. The remaining depend on the clickAttributionPolicy parameter.                The “data” array contains data rows whose values match the entries in the  “columns” array. The dimensions are always strings. The metrics are JSON objects  whose type is number. Some of these are natural numbers (e.g. clicks and  impressions) whereas others are decimal values. As mentioned earlier the  currency is assumed to be the local currency established by the advertiser.                The “row” value is a count of the number of rows in the data array, and can be  used to check the integrity of the data.                Further information on the campaign or seller (e.g. the seller name) can be  obtained from the existing V1 or V2 endpoints using the campaign and/or seller  ID values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.sellers(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: JWT Bearer Token (required)
        :param str interval_size: Specify the aggregation interval for events used to compute stats (default is \"day\")
        :param str click_attribution_policy: Specify the click attribution policy for salesUnits, revenue, CR, CPO, COS, and ROAS
        :param datetime start_date: Filter out all events that occur before date (default is the value of `endDate`)
        :param datetime end_date: Filter out all events that occur after date (default is today’s date)
        :param int count: Return up to the first count rows of data (default is to return all rows available)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.sellers_with_http_info(authorization, **kwargs)  # noqa: E501
        else:
            (data) = self.sellers_with_http_info(authorization, **kwargs)  # noqa: E501
            return data

    def sellers_with_http_info(self, authorization, **kwargs):  # noqa: E501
        """Get stats by seller.  # noqa: E501

        ## Dimensions                Get performance statistics aggregated for _sellers_. The seller id appears  in the output as the first column.                Aggregation can be done by `hour`, `day`, `month`, or `year`. The aggregation  interval size is controlled by `intervalSize`. The time interval appears in  the output as the second column.                ## Metrics                The metrics reported by this endpoint are                .  | Metric Group | Description  ---|--------------|------------  A | impressions | Number of times product is shown in a banner  B | clicks | Number of clicks on product  C | cost | Amount spent for clicks on products  D | saleUnits | Number of products sold attributed to clicks  E | revenue | Revenue generated by sales  F | CR = Conversion Rate | salesUnits / clicks  G | CPO = Cost Per Order | cost / salesUnits  H | COS = Cost of Sale | cost / revenue  I | ROAS = Return On Add Spend | revenue / cost                The last six metrics can be computed in two ways depending on the policy to count only  the sales that result from clicks on the same sellers product in a banner  (same-seller) or not (any-seller).  Reporting can be controlled by `clickAttributionPolicy`.                The 9 (or 15) metric values appear in the output as the final 9 (or 15) columns.                ## Filtering                The results can be filtered by date or count.                Filtering the results to events  that happened in a time interval is done by setting the `startDate` and  `endDate` filter parameters using the `yyyy-MM-DD` format. The start date  includes all events timestamped since the beginning of that day while the end  date includes events until the end of day. The maximum duration of the date  range is 1 year. If the aggregation interval is `hour`, then the maximum  duration of the date range is 1 month. Note that month and year aggregate values  may contain partial data for the interval if filtering by date.                Filtering the results to a maximum number of data rows is done by setting the  `count` filter parameter. When combined with startDate this can be used to perform  simple pagination.                ## Response Format                The representation format can be specified by MIME values in the Accept header.  For now the only supported values for the accept header is `application/json` and  `text/csv`.                ```json  {  \"columns\":[\"campaignId\", \"sellerId\", \"interval\", \"impressions\", \"clicks\", \"cost\", \"salesUnits\", \"revenue\", …],  \"data\":  [[\"2099873\",    \"321224\",   \"2018-01\",  2345,          128,      64.23,  9,            287.32,    …],            [\"2099873\",    \"321224\",   \"2018-02\",  1129,          98,       44.93,  6,            171.80,    …],            [\"2099873\",    \"321224\",   \"2018-03\",  3476,          322,      15.27,  18,           587.37,    …],            …           ],  \"rows\":  1600  }  ```                The JSON result is an object with three fields (`columns`, `data`, and `rows`). The  “columns” array acts as the header for the data rows. The categorical dimension  columns come first and will vary with the endpoint used (campaignId and/or  sellerId and interval). The interval column comes next. The interval size is  determined by the intervalSize parameter. This is followed by either nine or  fifteen metrics columns. The first three metrics (impressions, clicks, and cost)  always appear. The remaining depend on the clickAttributionPolicy parameter.                The “data” array contains data rows whose values match the entries in the  “columns” array. The dimensions are always strings. The metrics are JSON objects  whose type is number. Some of these are natural numbers (e.g. clicks and  impressions) whereas others are decimal values. As mentioned earlier the  currency is assumed to be the local currency established by the advertiser.                The “row” value is a count of the number of rows in the data array, and can be  used to check the integrity of the data.                Further information on the campaign or seller (e.g. the seller name) can be  obtained from the existing V1 or V2 endpoints using the campaign and/or seller  ID values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.sellers_with_http_info(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization: JWT Bearer Token (required)
        :param str interval_size: Specify the aggregation interval for events used to compute stats (default is \"day\")
        :param str click_attribution_policy: Specify the click attribution policy for salesUnits, revenue, CR, CPO, COS, and ROAS
        :param datetime start_date: Filter out all events that occur before date (default is the value of `endDate`)
        :param datetime end_date: Filter out all events that occur after date (default is today’s date)
        :param int count: Return up to the first count rows of data (default is to return all rows available)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization', 'interval_size', 'click_attribution_policy', 'start_date', 'end_date', 'count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sellers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ValueError("Missing the required parameter `authorization` when calling `sellers`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'interval_size' in local_var_params:
            query_params.append(('intervalSize', local_var_params['interval_size']))  # noqa: E501
        if 'click_attribution_policy' in local_var_params:
            query_params.append(('clickAttributionPolicy', local_var_params['click_attribution_policy']))  # noqa: E501
        if 'start_date' in local_var_params:
            query_params.append(('startDate', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params:
            query_params.append(('endDate', local_var_params['end_date']))  # noqa: E501
        if 'count' in local_var_params:
            query_params.append(('count', local_var_params['count']))  # noqa: E501

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/stats/sellers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

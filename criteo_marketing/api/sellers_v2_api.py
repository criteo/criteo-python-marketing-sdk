# coding: utf-8

"""
    Marketing API v.1.0

    IMPORTANT: This swagger links to Criteo production environment. Any test applied here will thus impact real campaigns.  # noqa: E501

    The version of the OpenAPI document: v.1.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from criteo_marketing.api_client import ApiClient
from criteo_marketing.exceptions import (
    ApiTypeError,
    ApiValueError
)


class SellersV2Api(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_seller_budgets(self, authorization, create_seller_budgets, **kwargs):  # noqa: E501
        """Create a collection of budgets.  # noqa: E501

        Create one or more new budgets to enable spending with the given limitations.  All three types of budgets can be created this way.                The following constraints apply when creating a new budget.                • <b>sellerId</b>: the seller MUST be supplied<br />  • <b>campaignIds</b>: a non-empty array of campaign ids MUST be supplied<br />  • <b>budgetType</b>: a budget type MUST be supplied<br />  • <b>amount</b>: an amount MAY be supplied only if the type is not Uncapped and if supplied it MUST be non-negative<br />  • <b>startDate</b>: a future start date MUST be supplied<br />  • <b>endDate</b>: an end date MAY be supplied and if supplied MUST be greater than the start date<br />                Other attributes MUST NOT be supplied.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_seller_budgets(authorization, create_seller_budgets, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param list[CreateSellerBudgetMapiMessage] create_seller_budgets: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[SellerBudgetMessage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_seller_budgets_with_http_info(authorization, create_seller_budgets, **kwargs)  # noqa: E501

    def create_seller_budgets_with_http_info(self, authorization, create_seller_budgets, **kwargs):  # noqa: E501
        """Create a collection of budgets.  # noqa: E501

        Create one or more new budgets to enable spending with the given limitations.  All three types of budgets can be created this way.                The following constraints apply when creating a new budget.                • <b>sellerId</b>: the seller MUST be supplied<br />  • <b>campaignIds</b>: a non-empty array of campaign ids MUST be supplied<br />  • <b>budgetType</b>: a budget type MUST be supplied<br />  • <b>amount</b>: an amount MAY be supplied only if the type is not Uncapped and if supplied it MUST be non-negative<br />  • <b>startDate</b>: a future start date MUST be supplied<br />  • <b>endDate</b>: an end date MAY be supplied and if supplied MUST be greater than the start date<br />                Other attributes MUST NOT be supplied.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_seller_budgets_with_http_info(authorization, create_seller_budgets, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param list[CreateSellerBudgetMapiMessage] create_seller_budgets: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[SellerBudgetMessage], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization', 'create_seller_budgets']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_seller_budgets" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `create_seller_budgets`")  # noqa: E501
        # verify the required parameter 'create_seller_budgets' is set
        if ('create_seller_budgets' not in local_var_params or
                local_var_params['create_seller_budgets'] is None):
            raise ApiValueError("Missing the required parameter `create_seller_budgets` when calling `create_seller_budgets`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_seller_budgets' in local_var_params:
            body_params = local_var_params['create_seller_budgets']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/budgets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SellerBudgetMessage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_seller_campaigns_by_seller(self, seller_id, authorization, seller_campaign, **kwargs):  # noqa: E501
        """Create a SellerCampaign  # noqa: E501

        Associate an existing Seller with an existing Campaign allowing for budget creation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_seller_campaigns_by_seller(seller_id, authorization, seller_campaign, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str seller_id: Supply a generated Id of an existing Seller (required)
        :param str authorization: JWT Bearer Token (required)
        :param CreateSellerCampaignMessageMapi seller_campaign: Supply the campaign Id and bid to create the mapping (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SellerCampaignMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_seller_campaigns_by_seller_with_http_info(seller_id, authorization, seller_campaign, **kwargs)  # noqa: E501

    def create_seller_campaigns_by_seller_with_http_info(self, seller_id, authorization, seller_campaign, **kwargs):  # noqa: E501
        """Create a SellerCampaign  # noqa: E501

        Associate an existing Seller with an existing Campaign allowing for budget creation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_seller_campaigns_by_seller_with_http_info(seller_id, authorization, seller_campaign, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str seller_id: Supply a generated Id of an existing Seller (required)
        :param str authorization: JWT Bearer Token (required)
        :param CreateSellerCampaignMessageMapi seller_campaign: Supply the campaign Id and bid to create the mapping (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SellerCampaignMessage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['seller_id', 'authorization', 'seller_campaign']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_seller_campaigns_by_seller" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'seller_id' is set
        if ('seller_id' not in local_var_params or
                local_var_params['seller_id'] is None):
            raise ApiValueError("Missing the required parameter `seller_id` when calling `create_seller_campaigns_by_seller`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `create_seller_campaigns_by_seller`")  # noqa: E501
        # verify the required parameter 'seller_campaign' is set
        if ('seller_campaign' not in local_var_params or
                local_var_params['seller_campaign'] is None):
            raise ApiValueError("Missing the required parameter `seller_campaign` when calling `create_seller_campaigns_by_seller`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'seller_id' in local_var_params:
            path_params['sellerId'] = local_var_params['seller_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'seller_campaign' in local_var_params:
            body_params = local_var_params['seller_campaign']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'text/html'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/sellers/{sellerId}/seller-campaigns', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SellerCampaignMessage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_sellers(self, advertiser_id, authorization, seller_names, **kwargs):  # noqa: E501
        """Create new sellers for an advertiser  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_sellers(advertiser_id, authorization, seller_names, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int advertiser_id: (required)
        :param str authorization: JWT Bearer Token (required)
        :param list[str] seller_names: (required)
        :param int partner_id:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[SellerBase]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_sellers_with_http_info(advertiser_id, authorization, seller_names, **kwargs)  # noqa: E501

    def create_sellers_with_http_info(self, advertiser_id, authorization, seller_names, **kwargs):  # noqa: E501
        """Create new sellers for an advertiser  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_sellers_with_http_info(advertiser_id, authorization, seller_names, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int advertiser_id: (required)
        :param str authorization: JWT Bearer Token (required)
        :param list[str] seller_names: (required)
        :param int partner_id:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[SellerBase], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['advertiser_id', 'authorization', 'seller_names', 'partner_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_sellers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'advertiser_id' is set
        if ('advertiser_id' not in local_var_params or
                local_var_params['advertiser_id'] is None):
            raise ApiValueError("Missing the required parameter `advertiser_id` when calling `create_sellers`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `create_sellers`")  # noqa: E501
        # verify the required parameter 'seller_names' is set
        if ('seller_names' not in local_var_params or
                local_var_params['seller_names'] is None):
            raise ApiValueError("Missing the required parameter `seller_names` when calling `create_sellers`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'advertiser_id' in local_var_params:
            path_params['advertiserId'] = local_var_params['advertiser_id']  # noqa: E501

        query_params = []
        if 'partner_id' in local_var_params:
            query_params.append(('partnerId', local_var_params['partner_id']))  # noqa: E501

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'seller_names' in local_var_params:
            body_params = local_var_params['seller_names']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/advertisers/{advertiserId}/sellers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SellerBase]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_advertiser(self, advertiser_id, authorization, **kwargs):  # noqa: E501
        """Get an advertiser.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_advertiser(advertiser_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int advertiser_id: (required)
        :param str authorization: JWT Bearer Token (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AdvertiserInfoMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_advertiser_with_http_info(advertiser_id, authorization, **kwargs)  # noqa: E501

    def get_advertiser_with_http_info(self, advertiser_id, authorization, **kwargs):  # noqa: E501
        """Get an advertiser.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_advertiser_with_http_info(advertiser_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int advertiser_id: (required)
        :param str authorization: JWT Bearer Token (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AdvertiserInfoMessage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['advertiser_id', 'authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_advertiser" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'advertiser_id' is set
        if ('advertiser_id' not in local_var_params or
                local_var_params['advertiser_id'] is None):
            raise ApiValueError("Missing the required parameter `advertiser_id` when calling `get_advertiser`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_advertiser`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'advertiser_id' in local_var_params:
            path_params['advertiserId'] = local_var_params['advertiser_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/advertisers/{advertiserId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdvertiserInfoMessage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_advertiser_campaigns(self, advertiser_id, authorization, **kwargs):  # noqa: E501
        """Get the collection of CRP campaigns associated with the advertiserId.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_advertiser_campaigns(advertiser_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int advertiser_id: (required)
        :param str authorization: JWT Bearer Token (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[AdvertiserCampaignMessage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_advertiser_campaigns_with_http_info(advertiser_id, authorization, **kwargs)  # noqa: E501

    def get_advertiser_campaigns_with_http_info(self, advertiser_id, authorization, **kwargs):  # noqa: E501
        """Get the collection of CRP campaigns associated with the advertiserId.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_advertiser_campaigns_with_http_info(advertiser_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int advertiser_id: (required)
        :param str authorization: JWT Bearer Token (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[AdvertiserCampaignMessage], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['advertiser_id', 'authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_advertiser_campaigns" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'advertiser_id' is set
        if ('advertiser_id' not in local_var_params or
                local_var_params['advertiser_id'] is None):
            raise ApiValueError("Missing the required parameter `advertiser_id` when calling `get_advertiser_campaigns`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_advertiser_campaigns`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'advertiser_id' in local_var_params:
            path_params['advertiserId'] = local_var_params['advertiser_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/advertisers/{advertiserId}/campaigns', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AdvertiserCampaignMessage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_advertiser_preview_limits(self, authorization, **kwargs):  # noqa: E501
        """Get the collection of advertisers preview limits associated with the authorized user.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_advertiser_preview_limits(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[AdvertiserQuotaMessage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_advertiser_preview_limits_with_http_info(authorization, **kwargs)  # noqa: E501

    def get_advertiser_preview_limits_with_http_info(self, authorization, **kwargs):  # noqa: E501
        """Get the collection of advertisers preview limits associated with the authorized user.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_advertiser_preview_limits_with_http_info(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[AdvertiserQuotaMessage], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_advertiser_preview_limits" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_advertiser_preview_limits`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/advertisers/preview-limit', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AdvertiserQuotaMessage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_advertisers(self, authorization, **kwargs):  # noqa: E501
        """Get the collection of advertisers associated with the user.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_advertisers(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[AdvertiserInfoMessage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_advertisers_with_http_info(authorization, **kwargs)  # noqa: E501

    def get_advertisers_with_http_info(self, authorization, **kwargs):  # noqa: E501
        """Get the collection of advertisers associated with the user.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_advertisers_with_http_info(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[AdvertiserInfoMessage], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_advertisers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_advertisers`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/advertisers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AdvertiserInfoMessage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_budgets_by_advertiser(self, advertiser_id, authorization, **kwargs):  # noqa: E501
        """Get CRP budgets for a specific advertiser  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_budgets_by_advertiser(advertiser_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int advertiser_id: (required)
        :param str authorization: JWT Bearer Token (required)
        :param str status:
        :param bool with_balance:
        :param bool with_spend:
        :param datetime end_after_date:
        :param datetime start_before_date:
        :param int budget_id:
        :param int seller_id:
        :param str type:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[SellerBudgetMessage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_budgets_by_advertiser_with_http_info(advertiser_id, authorization, **kwargs)  # noqa: E501

    def get_budgets_by_advertiser_with_http_info(self, advertiser_id, authorization, **kwargs):  # noqa: E501
        """Get CRP budgets for a specific advertiser  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_budgets_by_advertiser_with_http_info(advertiser_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int advertiser_id: (required)
        :param str authorization: JWT Bearer Token (required)
        :param str status:
        :param bool with_balance:
        :param bool with_spend:
        :param datetime end_after_date:
        :param datetime start_before_date:
        :param int budget_id:
        :param int seller_id:
        :param str type:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[SellerBudgetMessage], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['advertiser_id', 'authorization', 'status', 'with_balance', 'with_spend', 'end_after_date', 'start_before_date', 'budget_id', 'seller_id', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_budgets_by_advertiser" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'advertiser_id' is set
        if ('advertiser_id' not in local_var_params or
                local_var_params['advertiser_id'] is None):
            raise ApiValueError("Missing the required parameter `advertiser_id` when calling `get_budgets_by_advertiser`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_budgets_by_advertiser`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'advertiser_id' in local_var_params:
            path_params['advertiserId'] = local_var_params['advertiser_id']  # noqa: E501

        query_params = []
        if 'status' in local_var_params:
            query_params.append(('status', local_var_params['status']))  # noqa: E501
        if 'with_balance' in local_var_params:
            query_params.append(('withBalance', local_var_params['with_balance']))  # noqa: E501
        if 'with_spend' in local_var_params:
            query_params.append(('withSpend', local_var_params['with_spend']))  # noqa: E501
        if 'end_after_date' in local_var_params:
            query_params.append(('endAfterDate', local_var_params['end_after_date']))  # noqa: E501
        if 'start_before_date' in local_var_params:
            query_params.append(('startBeforeDate', local_var_params['start_before_date']))  # noqa: E501
        if 'budget_id' in local_var_params:
            query_params.append(('budgetId', local_var_params['budget_id']))  # noqa: E501
        if 'seller_id' in local_var_params:
            query_params.append(('sellerId', local_var_params['seller_id']))  # noqa: E501
        if 'type' in local_var_params:
            query_params.append(('type', local_var_params['type']))  # noqa: E501

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/advertisers/{advertiserId}/budgets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SellerBudgetMessage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_budgets_by_seller(self, seller_id, authorization, **kwargs):  # noqa: E501
        """Get a collection of budgets for this seller.  # noqa: E501

        Return a collection of budgets for this seller filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned, except those whose endDate is in the past. Returned budgets must satisfy all supplied filter  criteria if multiple parameters are used. See the budgets endpoint for additional details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_budgets_by_seller(seller_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str seller_id: Return only budgets belonging to the given seller. (required)
        :param str authorization: JWT Bearer Token (required)
        :param str status: Return only budgets with the given status.
        :param bool with_balance: Return only budgets with the given status.
        :param bool with_spend: Return budgets with any positive spend.
        :param datetime end_after_date: Return budgets that end after the given date using the `yyyy-MM-DD` format.              If param is not provided, default behavior is to only return budgets that have not yet ended.
        :param datetime start_before_date: Return budgets that start on or before the given date using the `yyyy-MM-DD` format.
        :param int campaign_id: Return only budgets that pay for a given campaign.
        :param str type: Return only budgets with the given budget type.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[SellerBudgetMessage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_budgets_by_seller_with_http_info(seller_id, authorization, **kwargs)  # noqa: E501

    def get_budgets_by_seller_with_http_info(self, seller_id, authorization, **kwargs):  # noqa: E501
        """Get a collection of budgets for this seller.  # noqa: E501

        Return a collection of budgets for this seller filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned, except those whose endDate is in the past. Returned budgets must satisfy all supplied filter  criteria if multiple parameters are used. See the budgets endpoint for additional details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_budgets_by_seller_with_http_info(seller_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str seller_id: Return only budgets belonging to the given seller. (required)
        :param str authorization: JWT Bearer Token (required)
        :param str status: Return only budgets with the given status.
        :param bool with_balance: Return only budgets with the given status.
        :param bool with_spend: Return budgets with any positive spend.
        :param datetime end_after_date: Return budgets that end after the given date using the `yyyy-MM-DD` format.              If param is not provided, default behavior is to only return budgets that have not yet ended.
        :param datetime start_before_date: Return budgets that start on or before the given date using the `yyyy-MM-DD` format.
        :param int campaign_id: Return only budgets that pay for a given campaign.
        :param str type: Return only budgets with the given budget type.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[SellerBudgetMessage], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['seller_id', 'authorization', 'status', 'with_balance', 'with_spend', 'end_after_date', 'start_before_date', 'campaign_id', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_budgets_by_seller" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'seller_id' is set
        if ('seller_id' not in local_var_params or
                local_var_params['seller_id'] is None):
            raise ApiValueError("Missing the required parameter `seller_id` when calling `get_budgets_by_seller`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_budgets_by_seller`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'seller_id' in local_var_params:
            path_params['sellerId'] = local_var_params['seller_id']  # noqa: E501

        query_params = []
        if 'status' in local_var_params:
            query_params.append(('status', local_var_params['status']))  # noqa: E501
        if 'with_balance' in local_var_params:
            query_params.append(('withBalance', local_var_params['with_balance']))  # noqa: E501
        if 'with_spend' in local_var_params:
            query_params.append(('withSpend', local_var_params['with_spend']))  # noqa: E501
        if 'end_after_date' in local_var_params:
            query_params.append(('endAfterDate', local_var_params['end_after_date']))  # noqa: E501
        if 'start_before_date' in local_var_params:
            query_params.append(('startBeforeDate', local_var_params['start_before_date']))  # noqa: E501
        if 'campaign_id' in local_var_params:
            query_params.append(('campaignId', local_var_params['campaign_id']))  # noqa: E501
        if 'type' in local_var_params:
            query_params.append(('type', local_var_params['type']))  # noqa: E501

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/sellers/{sellerId}/budgets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SellerBudgetMessage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_budgets_by_seller_campaign_id(self, seller_campaign_id, authorization, **kwargs):  # noqa: E501
        """Get a collection of budgets for this seller campaign.  # noqa: E501

        Return a collection of budgets for this seller campaign filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned, except those whose endDate is in the past. Returned budgets must satisfy all supplied filter  criteria if multiple parameters are used.                See the budgets endpoint for additional details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_budgets_by_seller_campaign_id(seller_campaign_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str seller_campaign_id: Return only budgets belonging to the given seller campaign. (required)
        :param str authorization: JWT Bearer Token (required)
        :param str status: Return only budgets with the given status.
        :param bool with_balance: Return only budgets with a positive balance.
        :param bool with_spend: Return budgets with a positive spend.
        :param datetime end_after_date: Return budgets that end after the given date using the `yyyy-MM-DD` format.               If param is not provided, default behavior is to only return budgets that have not yet ended.
        :param datetime start_before_date: Return budgets that start on or before the given date using the `yyyy-MM-DD` format.
        :param str type: Return only budgets with the given budget type.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[SellerBudgetMessage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_budgets_by_seller_campaign_id_with_http_info(seller_campaign_id, authorization, **kwargs)  # noqa: E501

    def get_budgets_by_seller_campaign_id_with_http_info(self, seller_campaign_id, authorization, **kwargs):  # noqa: E501
        """Get a collection of budgets for this seller campaign.  # noqa: E501

        Return a collection of budgets for this seller campaign filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned, except those whose endDate is in the past. Returned budgets must satisfy all supplied filter  criteria if multiple parameters are used.                See the budgets endpoint for additional details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_budgets_by_seller_campaign_id_with_http_info(seller_campaign_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str seller_campaign_id: Return only budgets belonging to the given seller campaign. (required)
        :param str authorization: JWT Bearer Token (required)
        :param str status: Return only budgets with the given status.
        :param bool with_balance: Return only budgets with a positive balance.
        :param bool with_spend: Return budgets with a positive spend.
        :param datetime end_after_date: Return budgets that end after the given date using the `yyyy-MM-DD` format.               If param is not provided, default behavior is to only return budgets that have not yet ended.
        :param datetime start_before_date: Return budgets that start on or before the given date using the `yyyy-MM-DD` format.
        :param str type: Return only budgets with the given budget type.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[SellerBudgetMessage], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['seller_campaign_id', 'authorization', 'status', 'with_balance', 'with_spend', 'end_after_date', 'start_before_date', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_budgets_by_seller_campaign_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'seller_campaign_id' is set
        if ('seller_campaign_id' not in local_var_params or
                local_var_params['seller_campaign_id'] is None):
            raise ApiValueError("Missing the required parameter `seller_campaign_id` when calling `get_budgets_by_seller_campaign_id`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_budgets_by_seller_campaign_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'seller_campaign_id' in local_var_params:
            path_params['sellerCampaignId'] = local_var_params['seller_campaign_id']  # noqa: E501

        query_params = []
        if 'status' in local_var_params:
            query_params.append(('status', local_var_params['status']))  # noqa: E501
        if 'with_balance' in local_var_params:
            query_params.append(('withBalance', local_var_params['with_balance']))  # noqa: E501
        if 'with_spend' in local_var_params:
            query_params.append(('withSpend', local_var_params['with_spend']))  # noqa: E501
        if 'end_after_date' in local_var_params:
            query_params.append(('endAfterDate', local_var_params['end_after_date']))  # noqa: E501
        if 'start_before_date' in local_var_params:
            query_params.append(('startBeforeDate', local_var_params['start_before_date']))  # noqa: E501
        if 'type' in local_var_params:
            query_params.append(('type', local_var_params['type']))  # noqa: E501

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/seller-campaigns/{sellerCampaignId}/budgets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SellerBudgetMessage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_seller(self, seller_id, authorization, **kwargs):  # noqa: E501
        """Get details for a seller.  # noqa: E501

        Returns details for the selected seller.  For example                    {          \"id\" : \"123456\"          \"sellerName\": \"HBogart\",      }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_seller(seller_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str seller_id: Id of the seller. (required)
        :param str authorization: JWT Bearer Token (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SellerBase
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_seller_with_http_info(seller_id, authorization, **kwargs)  # noqa: E501

    def get_seller_with_http_info(self, seller_id, authorization, **kwargs):  # noqa: E501
        """Get details for a seller.  # noqa: E501

        Returns details for the selected seller.  For example                    {          \"id\" : \"123456\"          \"sellerName\": \"HBogart\",      }  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_seller_with_http_info(seller_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str seller_id: Id of the seller. (required)
        :param str authorization: JWT Bearer Token (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SellerBase, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['seller_id', 'authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_seller" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'seller_id' is set
        if ('seller_id' not in local_var_params or
                local_var_params['seller_id'] is None):
            raise ApiValueError("Missing the required parameter `seller_id` when calling `get_seller`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_seller`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'seller_id' in local_var_params:
            path_params['sellerId'] = local_var_params['seller_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/sellers/{sellerId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SellerBase',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_seller_ad_demo(self, advertiser_id, seller_id, authorization, **kwargs):  # noqa: E501
        """Get a preview of an HTML ad with products belonging to the provided seller  # noqa: E501

        • <b>advertiserId</b>: Valid crp advertiserId, seller belongs to provided advertiser<br />  • <b>sellerId</b>: Products from given SellerId will fill the ad preview, must be existing crp sellerId<br />  • <b>campaignId</b>: CampaignId may be supplied if there is a specific design set configured for the provided campaign, Seller-Campaign must be valid in crp<br />  • <b>height</b>: height may be supplied to request a specific ad preview height.  Default height: 250<br />  • <b>width</b>: width may be supplied to request a specific ad preview width. Default width: 300<br />                Ad preview api calls are capped to 1000 per day per advertiser by default.  Current usage, limit, and period can be found using v2/crp/advertisers/preview-limit  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_seller_ad_demo(advertiser_id, seller_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int advertiser_id: (required)
        :param int seller_id: (required)
        :param str authorization: JWT Bearer Token (required)
        :param int campaign_id:
        :param int height:
        :param int width:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_seller_ad_demo_with_http_info(advertiser_id, seller_id, authorization, **kwargs)  # noqa: E501

    def get_seller_ad_demo_with_http_info(self, advertiser_id, seller_id, authorization, **kwargs):  # noqa: E501
        """Get a preview of an HTML ad with products belonging to the provided seller  # noqa: E501

        • <b>advertiserId</b>: Valid crp advertiserId, seller belongs to provided advertiser<br />  • <b>sellerId</b>: Products from given SellerId will fill the ad preview, must be existing crp sellerId<br />  • <b>campaignId</b>: CampaignId may be supplied if there is a specific design set configured for the provided campaign, Seller-Campaign must be valid in crp<br />  • <b>height</b>: height may be supplied to request a specific ad preview height.  Default height: 250<br />  • <b>width</b>: width may be supplied to request a specific ad preview width. Default width: 300<br />                Ad preview api calls are capped to 1000 per day per advertiser by default.  Current usage, limit, and period can be found using v2/crp/advertisers/preview-limit  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_seller_ad_demo_with_http_info(advertiser_id, seller_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int advertiser_id: (required)
        :param int seller_id: (required)
        :param str authorization: JWT Bearer Token (required)
        :param int campaign_id:
        :param int height:
        :param int width:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['advertiser_id', 'seller_id', 'authorization', 'campaign_id', 'height', 'width']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_seller_ad_demo" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'advertiser_id' is set
        if ('advertiser_id' not in local_var_params or
                local_var_params['advertiser_id'] is None):
            raise ApiValueError("Missing the required parameter `advertiser_id` when calling `get_seller_ad_demo`")  # noqa: E501
        # verify the required parameter 'seller_id' is set
        if ('seller_id' not in local_var_params or
                local_var_params['seller_id'] is None):
            raise ApiValueError("Missing the required parameter `seller_id` when calling `get_seller_ad_demo`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_seller_ad_demo`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'advertiser_id' in local_var_params:
            path_params['advertiserId'] = local_var_params['advertiser_id']  # noqa: E501

        query_params = []
        if 'seller_id' in local_var_params:
            query_params.append(('sellerId', local_var_params['seller_id']))  # noqa: E501
        if 'campaign_id' in local_var_params:
            query_params.append(('campaignId', local_var_params['campaign_id']))  # noqa: E501
        if 'height' in local_var_params:
            query_params.append(('height', local_var_params['height']))  # noqa: E501
        if 'width' in local_var_params:
            query_params.append(('width', local_var_params['width']))  # noqa: E501

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/advertisers/{advertiserId}/ad-preview', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_seller_budget(self, budget_id, authorization, **kwargs):  # noqa: E501
        """Get details for a budget.  # noqa: E501

        Return a budget. For example:                    {          \"id\": \"1759183\",          \"sellerId\": \"321392\",          \"campaignIds\": [              143962          ],          \"budgetType\": \"Capped\",          \"amount\": 1000,          \"startDate\": \"2021-01-11\",          \"endDate\": \"2021-01-12\",          \"spend\": null,          \"status\": \"Active\"      }                A budget limits the spend of a seller for one or more campaigns.                There are three types of budget:<br /><b>Uncapped</b> budgets put no limit on the total amount of spend.<br /><b>Capped</b> budgets limit the total spend to a fixed amount.<br /><b>Daily</b> budgets limit daily spend to a fixed amount.<br />                In addition, budgets can limit the spend to a specific range of dates using  the start and end date attributes. Finally a budget must be active to be used.                <b>Spend</b> approximates the current spend against this budget. There may be a lag  between when an ad is clicked and the time it accrues to the spend.  Daily budgets  show spend against the most recent day only.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_seller_budget(budget_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int budget_id: Id of the budget. (required)
        :param str authorization: JWT Bearer Token (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SellerBudgetMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_seller_budget_with_http_info(budget_id, authorization, **kwargs)  # noqa: E501

    def get_seller_budget_with_http_info(self, budget_id, authorization, **kwargs):  # noqa: E501
        """Get details for a budget.  # noqa: E501

        Return a budget. For example:                    {          \"id\": \"1759183\",          \"sellerId\": \"321392\",          \"campaignIds\": [              143962          ],          \"budgetType\": \"Capped\",          \"amount\": 1000,          \"startDate\": \"2021-01-11\",          \"endDate\": \"2021-01-12\",          \"spend\": null,          \"status\": \"Active\"      }                A budget limits the spend of a seller for one or more campaigns.                There are three types of budget:<br /><b>Uncapped</b> budgets put no limit on the total amount of spend.<br /><b>Capped</b> budgets limit the total spend to a fixed amount.<br /><b>Daily</b> budgets limit daily spend to a fixed amount.<br />                In addition, budgets can limit the spend to a specific range of dates using  the start and end date attributes. Finally a budget must be active to be used.                <b>Spend</b> approximates the current spend against this budget. There may be a lag  between when an ad is clicked and the time it accrues to the spend.  Daily budgets  show spend against the most recent day only.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_seller_budget_with_http_info(budget_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int budget_id: Id of the budget. (required)
        :param str authorization: JWT Bearer Token (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SellerBudgetMessage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['budget_id', 'authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_seller_budget" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'budget_id' is set
        if ('budget_id' not in local_var_params or
                local_var_params['budget_id'] is None):
            raise ApiValueError("Missing the required parameter `budget_id` when calling `get_seller_budget`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_seller_budget`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'budget_id' in local_var_params:
            path_params['budgetId'] = local_var_params['budget_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/budgets/{budgetId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SellerBudgetMessage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_seller_budgets(self, authorization, **kwargs):  # noqa: E501
        """Get a collection of budgets.  # noqa: E501

        Return a collection of budgets filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned, except those whose endDate is in the past. Returned budgets must satisfy all supplied filter  criteria if multiple parameters are used.                <b>Date filter.</b> Filtering can return only budgets that were active for a  date range by specifying the startBeforeDate and endAfterDate. Leaving off the startBeforeDate  value makes budgets with any startDate qualify, whereas when leaving off the endAfterDate value will only return  budgets whose endDate has not already passed. To get budgets that were active  on a specific date, set both values to that day.                <b>Spend.</b> If the endAfterDate is supplied, the spend excludes spend that  happened after that date. In the case of a daily budget, only the spend for  the final day is displayed.                See the budgets endpoint for additional details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_seller_budgets(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param str status: Return only budgets with the given status.
        :param bool with_balance: Return only budgets with the given status.
        :param bool with_spend: Return budgets with any positive spend.
        :param datetime end_after_date: Return budgets that end after the given date using the `yyyy-MM-DD` format.               If param is not provided, default behavior is to only return budgets that have not yet ended.
        :param datetime start_before_date: Return budgets that start on or before the given date using the `yyyy-MM-DD` format.
        :param int campaign_id: Return only budgets that pay for a given campaign.
        :param str seller_id: Return only budgets belonging to the given seller.
        :param str type: Return only budgets with the given budget type.
        :param int advertiser_id: Return only budgets belonging to the specified advertiser
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[SellerBudgetMessage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_seller_budgets_with_http_info(authorization, **kwargs)  # noqa: E501

    def get_seller_budgets_with_http_info(self, authorization, **kwargs):  # noqa: E501
        """Get a collection of budgets.  # noqa: E501

        Return a collection of budgets filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned, except those whose endDate is in the past. Returned budgets must satisfy all supplied filter  criteria if multiple parameters are used.                <b>Date filter.</b> Filtering can return only budgets that were active for a  date range by specifying the startBeforeDate and endAfterDate. Leaving off the startBeforeDate  value makes budgets with any startDate qualify, whereas when leaving off the endAfterDate value will only return  budgets whose endDate has not already passed. To get budgets that were active  on a specific date, set both values to that day.                <b>Spend.</b> If the endAfterDate is supplied, the spend excludes spend that  happened after that date. In the case of a daily budget, only the spend for  the final day is displayed.                See the budgets endpoint for additional details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_seller_budgets_with_http_info(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param str status: Return only budgets with the given status.
        :param bool with_balance: Return only budgets with the given status.
        :param bool with_spend: Return budgets with any positive spend.
        :param datetime end_after_date: Return budgets that end after the given date using the `yyyy-MM-DD` format.               If param is not provided, default behavior is to only return budgets that have not yet ended.
        :param datetime start_before_date: Return budgets that start on or before the given date using the `yyyy-MM-DD` format.
        :param int campaign_id: Return only budgets that pay for a given campaign.
        :param str seller_id: Return only budgets belonging to the given seller.
        :param str type: Return only budgets with the given budget type.
        :param int advertiser_id: Return only budgets belonging to the specified advertiser
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[SellerBudgetMessage], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization', 'status', 'with_balance', 'with_spend', 'end_after_date', 'start_before_date', 'campaign_id', 'seller_id', 'type', 'advertiser_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_seller_budgets" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_seller_budgets`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'status' in local_var_params:
            query_params.append(('status', local_var_params['status']))  # noqa: E501
        if 'with_balance' in local_var_params:
            query_params.append(('withBalance', local_var_params['with_balance']))  # noqa: E501
        if 'with_spend' in local_var_params:
            query_params.append(('withSpend', local_var_params['with_spend']))  # noqa: E501
        if 'end_after_date' in local_var_params:
            query_params.append(('endAfterDate', local_var_params['end_after_date']))  # noqa: E501
        if 'start_before_date' in local_var_params:
            query_params.append(('startBeforeDate', local_var_params['start_before_date']))  # noqa: E501
        if 'campaign_id' in local_var_params:
            query_params.append(('campaignId', local_var_params['campaign_id']))  # noqa: E501
        if 'seller_id' in local_var_params:
            query_params.append(('sellerId', local_var_params['seller_id']))  # noqa: E501
        if 'type' in local_var_params:
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'advertiser_id' in local_var_params:
            query_params.append(('advertiserId', local_var_params['advertiser_id']))  # noqa: E501

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/budgets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SellerBudgetMessage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_seller_campaign(self, seller_campaign_id, authorization, **kwargs):  # noqa: E501
        """Get details for a seller campaign.  # noqa: E501

        Return details for a seller campaign.  For example,                    {          \"id\": \"543210.123456\",          \"suspendedSince\": \"2018-07-30\",          \"sellerId\": \"543210\",          \"campaignId\": 123456,          \"bid\": 1.55      }                An active seller campaign is one for which the value of <b>suspendedSince</b> is null and  the <b>bid</b> is positive. The currency of the bid is the <b>bidCurrency</b> of the  associated campaign.                Any active seller campaign must also have an active total (capped or uncapped) budget.  It may optionally have an active daily budget as well to further limit spending.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_seller_campaign(seller_campaign_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str seller_campaign_id: Id of the seller campaign. (required)
        :param str authorization: JWT Bearer Token (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SellerCampaignMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_seller_campaign_with_http_info(seller_campaign_id, authorization, **kwargs)  # noqa: E501

    def get_seller_campaign_with_http_info(self, seller_campaign_id, authorization, **kwargs):  # noqa: E501
        """Get details for a seller campaign.  # noqa: E501

        Return details for a seller campaign.  For example,                    {          \"id\": \"543210.123456\",          \"suspendedSince\": \"2018-07-30\",          \"sellerId\": \"543210\",          \"campaignId\": 123456,          \"bid\": 1.55      }                An active seller campaign is one for which the value of <b>suspendedSince</b> is null and  the <b>bid</b> is positive. The currency of the bid is the <b>bidCurrency</b> of the  associated campaign.                Any active seller campaign must also have an active total (capped or uncapped) budget.  It may optionally have an active daily budget as well to further limit spending.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_seller_campaign_with_http_info(seller_campaign_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str seller_campaign_id: Id of the seller campaign. (required)
        :param str authorization: JWT Bearer Token (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SellerCampaignMessage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['seller_campaign_id', 'authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_seller_campaign" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'seller_campaign_id' is set
        if ('seller_campaign_id' not in local_var_params or
                local_var_params['seller_campaign_id'] is None):
            raise ApiValueError("Missing the required parameter `seller_campaign_id` when calling `get_seller_campaign`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_seller_campaign`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'seller_campaign_id' in local_var_params:
            path_params['sellerCampaignId'] = local_var_params['seller_campaign_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/seller-campaigns/{sellerCampaignId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SellerCampaignMessage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_seller_campaigns(self, authorization, **kwargs):  # noqa: E501
        """Get a collection of seller campaigns.  # noqa: E501

        Return a collection of seller campaigns filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned sellers must satisfy all supplied filter  criteria if multiple parameters are used.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_seller_campaigns(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param str seller_status: Return only seller campaigns for sellers with the given status.
        :param str seller_id: Return only seller campaigns belonging to the given seller.
        :param int campaign_id: Return only seller campaigns associated with the given campaign.
        :param str budget_status: Return only seller campaigns whose budget has the given status.
        :param int advertiser_id: Return only seller belonging to the specified advertiser
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[SellerCampaignMessage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_seller_campaigns_with_http_info(authorization, **kwargs)  # noqa: E501

    def get_seller_campaigns_with_http_info(self, authorization, **kwargs):  # noqa: E501
        """Get a collection of seller campaigns.  # noqa: E501

        Return a collection of seller campaigns filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned sellers must satisfy all supplied filter  criteria if multiple parameters are used.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_seller_campaigns_with_http_info(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param str seller_status: Return only seller campaigns for sellers with the given status.
        :param str seller_id: Return only seller campaigns belonging to the given seller.
        :param int campaign_id: Return only seller campaigns associated with the given campaign.
        :param str budget_status: Return only seller campaigns whose budget has the given status.
        :param int advertiser_id: Return only seller belonging to the specified advertiser
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[SellerCampaignMessage], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization', 'seller_status', 'seller_id', 'campaign_id', 'budget_status', 'advertiser_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_seller_campaigns" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_seller_campaigns`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'seller_status' in local_var_params:
            query_params.append(('sellerStatus', local_var_params['seller_status']))  # noqa: E501
        if 'seller_id' in local_var_params:
            query_params.append(('sellerId', local_var_params['seller_id']))  # noqa: E501
        if 'campaign_id' in local_var_params:
            query_params.append(('campaignId', local_var_params['campaign_id']))  # noqa: E501
        if 'budget_status' in local_var_params:
            query_params.append(('budgetStatus', local_var_params['budget_status']))  # noqa: E501
        if 'advertiser_id' in local_var_params:
            query_params.append(('advertiserId', local_var_params['advertiser_id']))  # noqa: E501

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/seller-campaigns', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SellerCampaignMessage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_seller_campaigns_by_advertiser(self, advertiser_id, authorization, **kwargs):  # noqa: E501
        """Get CRP seller-campaigns for a specific advertiser  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_seller_campaigns_by_advertiser(advertiser_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int advertiser_id: (required)
        :param str authorization: JWT Bearer Token (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[SellerCampaignMessage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_seller_campaigns_by_advertiser_with_http_info(advertiser_id, authorization, **kwargs)  # noqa: E501

    def get_seller_campaigns_by_advertiser_with_http_info(self, advertiser_id, authorization, **kwargs):  # noqa: E501
        """Get CRP seller-campaigns for a specific advertiser  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_seller_campaigns_by_advertiser_with_http_info(advertiser_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int advertiser_id: (required)
        :param str authorization: JWT Bearer Token (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[SellerCampaignMessage], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['advertiser_id', 'authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_seller_campaigns_by_advertiser" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'advertiser_id' is set
        if ('advertiser_id' not in local_var_params or
                local_var_params['advertiser_id'] is None):
            raise ApiValueError("Missing the required parameter `advertiser_id` when calling `get_seller_campaigns_by_advertiser`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_seller_campaigns_by_advertiser`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'advertiser_id' in local_var_params:
            path_params['advertiserId'] = local_var_params['advertiser_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/advertisers/{advertiserId}/seller-campaigns', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SellerCampaignMessage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_seller_campaigns_by_seller(self, seller_id, authorization, **kwargs):  # noqa: E501
        """Get a collection of seller campaigns for this seller.  # noqa: E501

        Return a collection of seller campaigns for this seller filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned sellers must satisfy all supplied filter  criteria if multiple parameters are used.  See the seller campaigns endpoint for additional details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_seller_campaigns_by_seller(seller_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str seller_id: Return only seller campaigns belonging to the given seller. (required)
        :param str authorization: JWT Bearer Token (required)
        :param str seller_status: Return only seller campaigns for sellers with the given status.
        :param int campaign_id: Return only seller campaigns associated with the given campaign.
        :param str budget_status: Return only seller campaigns whose budget has the given status.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[SellerCampaignMessage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_seller_campaigns_by_seller_with_http_info(seller_id, authorization, **kwargs)  # noqa: E501

    def get_seller_campaigns_by_seller_with_http_info(self, seller_id, authorization, **kwargs):  # noqa: E501
        """Get a collection of seller campaigns for this seller.  # noqa: E501

        Return a collection of seller campaigns for this seller filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned sellers must satisfy all supplied filter  criteria if multiple parameters are used.  See the seller campaigns endpoint for additional details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_seller_campaigns_by_seller_with_http_info(seller_id, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str seller_id: Return only seller campaigns belonging to the given seller. (required)
        :param str authorization: JWT Bearer Token (required)
        :param str seller_status: Return only seller campaigns for sellers with the given status.
        :param int campaign_id: Return only seller campaigns associated with the given campaign.
        :param str budget_status: Return only seller campaigns whose budget has the given status.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[SellerCampaignMessage], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['seller_id', 'authorization', 'seller_status', 'campaign_id', 'budget_status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_seller_campaigns_by_seller" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'seller_id' is set
        if ('seller_id' not in local_var_params or
                local_var_params['seller_id'] is None):
            raise ApiValueError("Missing the required parameter `seller_id` when calling `get_seller_campaigns_by_seller`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_seller_campaigns_by_seller`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'seller_id' in local_var_params:
            path_params['sellerId'] = local_var_params['seller_id']  # noqa: E501

        query_params = []
        if 'seller_status' in local_var_params:
            query_params.append(('sellerStatus', local_var_params['seller_status']))  # noqa: E501
        if 'campaign_id' in local_var_params:
            query_params.append(('campaignId', local_var_params['campaign_id']))  # noqa: E501
        if 'budget_status' in local_var_params:
            query_params.append(('budgetStatus', local_var_params['budget_status']))  # noqa: E501

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/sellers/{sellerId}/seller-campaigns', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SellerCampaignMessage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sellers(self, authorization, **kwargs):  # noqa: E501
        """Get a collection of sellers.  # noqa: E501

        Return a collection of sellers filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned sellers must satisfy all supplied filter  criteria if multiple parameters are used.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sellers(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param str seller_status: Return only sellers with specific status.
        :param bool with_products: Return only sellers with or without products in catalog.
        :param str with_budget_status: Return only sellers with specific budget status.
        :param str seller_name: Return only sellers with the matching name.
        :param int advertiser_id: Return only sellers belonging to the specified advertiser
        :param int campaign_id: Return only sellers belonging to the specified campaign
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[SellerBase]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_sellers_with_http_info(authorization, **kwargs)  # noqa: E501

    def get_sellers_with_http_info(self, authorization, **kwargs):  # noqa: E501
        """Get a collection of sellers.  # noqa: E501

        Return a collection of sellers filtered by optional filter parameters.  If all parameters are omitted the entire collection to which the user has  access is returned. Returned sellers must satisfy all supplied filter  criteria if multiple parameters are used.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sellers_with_http_info(authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param str seller_status: Return only sellers with specific status.
        :param bool with_products: Return only sellers with or without products in catalog.
        :param str with_budget_status: Return only sellers with specific budget status.
        :param str seller_name: Return only sellers with the matching name.
        :param int advertiser_id: Return only sellers belonging to the specified advertiser
        :param int campaign_id: Return only sellers belonging to the specified campaign
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[SellerBase], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization', 'seller_status', 'with_products', 'with_budget_status', 'seller_name', 'advertiser_id', 'campaign_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sellers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `get_sellers`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'seller_status' in local_var_params:
            query_params.append(('sellerStatus', local_var_params['seller_status']))  # noqa: E501
        if 'with_products' in local_var_params:
            query_params.append(('withProducts', local_var_params['with_products']))  # noqa: E501
        if 'with_budget_status' in local_var_params:
            query_params.append(('withBudgetStatus', local_var_params['with_budget_status']))  # noqa: E501
        if 'seller_name' in local_var_params:
            query_params.append(('sellerName', local_var_params['seller_name']))  # noqa: E501
        if 'advertiser_id' in local_var_params:
            query_params.append(('advertiserId', local_var_params['advertiser_id']))  # noqa: E501
        if 'campaign_id' in local_var_params:
            query_params.append(('campaignId', local_var_params['campaign_id']))  # noqa: E501

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/sellers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SellerBase]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_seller_budget(self, budget_id, authorization, message, **kwargs):  # noqa: E501
        """Modify a single budget.  # noqa: E501

        Modify an existing active budget to change its limitations or status.  All three types of budgets can be modified.                See the additional restrictions listed in the PATCH budgets endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_seller_budget(budget_id, authorization, message, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int budget_id: (required)
        :param str authorization: JWT Bearer Token (required)
        :param UpdateSellerBudgetMessageBase message: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SellerBudgetMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_seller_budget_with_http_info(budget_id, authorization, message, **kwargs)  # noqa: E501

    def update_seller_budget_with_http_info(self, budget_id, authorization, message, **kwargs):  # noqa: E501
        """Modify a single budget.  # noqa: E501

        Modify an existing active budget to change its limitations or status.  All three types of budgets can be modified.                See the additional restrictions listed in the PATCH budgets endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_seller_budget_with_http_info(budget_id, authorization, message, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int budget_id: (required)
        :param str authorization: JWT Bearer Token (required)
        :param UpdateSellerBudgetMessageBase message: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SellerBudgetMessage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['budget_id', 'authorization', 'message']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_seller_budget" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'budget_id' is set
        if ('budget_id' not in local_var_params or
                local_var_params['budget_id'] is None):
            raise ApiValueError("Missing the required parameter `budget_id` when calling `update_seller_budget`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `update_seller_budget`")  # noqa: E501
        # verify the required parameter 'message' is set
        if ('message' not in local_var_params or
                local_var_params['message'] is None):
            raise ApiValueError("Missing the required parameter `message` when calling `update_seller_budget`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'budget_id' in local_var_params:
            path_params['budgetId'] = local_var_params['budget_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'message' in local_var_params:
            body_params = local_var_params['message']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'text/html'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'text/json', 'application/x-www-form-urlencoded', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/budgets/{budgetId}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SellerBudgetMessage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_seller_budgets(self, authorization, update_seller_budgets, **kwargs):  # noqa: E501
        """Modify a collection of budgets.  # noqa: E501

        Modify one or more existing active budgets to change their limitations or status.  All three types of budgets can be modified.                The following constraints apply when modifying an existing budget.                • <b>campaignIds</b>: a non-empty subset of the original campaign ids MAY be supplied<br />  • <b>amount</b>: an amount MAY be supplied only if the type is not Uncapped and if supplied it MUST be non-negative<br />  • <b>startDate</b>: a future start date MAY be supplied for budgets that have not yet started<br />  • <b>endDate</b>: an end date MAY be supplied and if supplied MUST be a future date greater than the start date<br />                Other attributes MUST NOT be supplied.                Adding new campaigns to a budget is not allowed. In addition, reducing the amount for  a Capped budget to a value less than the current spend not allowed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_seller_budgets(authorization, update_seller_budgets, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param list[UpdateSellerBudgetMessage] update_seller_budgets: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[SellerBudgetMessage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_seller_budgets_with_http_info(authorization, update_seller_budgets, **kwargs)  # noqa: E501

    def update_seller_budgets_with_http_info(self, authorization, update_seller_budgets, **kwargs):  # noqa: E501
        """Modify a collection of budgets.  # noqa: E501

        Modify one or more existing active budgets to change their limitations or status.  All three types of budgets can be modified.                The following constraints apply when modifying an existing budget.                • <b>campaignIds</b>: a non-empty subset of the original campaign ids MAY be supplied<br />  • <b>amount</b>: an amount MAY be supplied only if the type is not Uncapped and if supplied it MUST be non-negative<br />  • <b>startDate</b>: a future start date MAY be supplied for budgets that have not yet started<br />  • <b>endDate</b>: an end date MAY be supplied and if supplied MUST be a future date greater than the start date<br />                Other attributes MUST NOT be supplied.                Adding new campaigns to a budget is not allowed. In addition, reducing the amount for  a Capped budget to a value less than the current spend not allowed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_seller_budgets_with_http_info(authorization, update_seller_budgets, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param list[UpdateSellerBudgetMessage] update_seller_budgets: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[SellerBudgetMessage], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization', 'update_seller_budgets']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_seller_budgets" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `update_seller_budgets`")  # noqa: E501
        # verify the required parameter 'update_seller_budgets' is set
        if ('update_seller_budgets' not in local_var_params or
                local_var_params['update_seller_budgets'] is None):
            raise ApiValueError("Missing the required parameter `update_seller_budgets` when calling `update_seller_budgets`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_seller_budgets' in local_var_params:
            body_params = local_var_params['update_seller_budgets']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/budgets', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SellerBudgetMessage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_seller_campaign(self, seller_campaign_id, bid, authorization, **kwargs):  # noqa: E501
        """Update an existing seller campaign.  # noqa: E501

        Patching a seller campaign allows the bid to be modified. The bid must be a non-negative value.  Setting the bid to zero will make a seller campaign inactive.                The currency used for bids will be the default currency of the campaign.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_seller_campaign(seller_campaign_id, bid, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str seller_campaign_id: Id of the existing seller campaign to update (required)
        :param float bid: The new bid for the seller campaign. (required)
        :param str authorization: JWT Bearer Token (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SellerCampaignMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_seller_campaign_with_http_info(seller_campaign_id, bid, authorization, **kwargs)  # noqa: E501

    def update_seller_campaign_with_http_info(self, seller_campaign_id, bid, authorization, **kwargs):  # noqa: E501
        """Update an existing seller campaign.  # noqa: E501

        Patching a seller campaign allows the bid to be modified. The bid must be a non-negative value.  Setting the bid to zero will make a seller campaign inactive.                The currency used for bids will be the default currency of the campaign.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_seller_campaign_with_http_info(seller_campaign_id, bid, authorization, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str seller_campaign_id: Id of the existing seller campaign to update (required)
        :param float bid: The new bid for the seller campaign. (required)
        :param str authorization: JWT Bearer Token (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SellerCampaignMessage, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['seller_campaign_id', 'bid', 'authorization']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_seller_campaign" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'seller_campaign_id' is set
        if ('seller_campaign_id' not in local_var_params or
                local_var_params['seller_campaign_id'] is None):
            raise ApiValueError("Missing the required parameter `seller_campaign_id` when calling `update_seller_campaign`")  # noqa: E501
        # verify the required parameter 'bid' is set
        if ('bid' not in local_var_params or
                local_var_params['bid'] is None):
            raise ApiValueError("Missing the required parameter `bid` when calling `update_seller_campaign`")  # noqa: E501
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `update_seller_campaign`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'seller_campaign_id' in local_var_params:
            path_params['sellerCampaignId'] = local_var_params['seller_campaign_id']  # noqa: E501

        query_params = []
        if 'bid' in local_var_params:
            query_params.append(('bid', local_var_params['bid']))  # noqa: E501

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/seller-campaigns/{sellerCampaignId}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SellerCampaignMessage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_seller_campaigns(self, authorization, campaign_messages, **kwargs):  # noqa: E501
        """Update a collection of seller campaigns.  # noqa: E501

        Patching a collection of seller campaigns allows their bids to be modified.  Each bid must be a non-negative value. Setting the bid to zero will make a seller campaign inactive.                The currency used for bids will be the default currency of the campaign.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_seller_campaigns(authorization, campaign_messages, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param list[SellerCampaignUpdate] campaign_messages: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[SellerCampaignMessage]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_seller_campaigns_with_http_info(authorization, campaign_messages, **kwargs)  # noqa: E501

    def update_seller_campaigns_with_http_info(self, authorization, campaign_messages, **kwargs):  # noqa: E501
        """Update a collection of seller campaigns.  # noqa: E501

        Patching a collection of seller campaigns allows their bids to be modified.  Each bid must be a non-negative value. Setting the bid to zero will make a seller campaign inactive.                The currency used for bids will be the default currency of the campaign.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_seller_campaigns_with_http_info(authorization, campaign_messages, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str authorization: JWT Bearer Token (required)
        :param list[SellerCampaignUpdate] campaign_messages: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[SellerCampaignMessage], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['authorization', 'campaign_messages']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_seller_campaigns" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'authorization' is set
        if ('authorization' not in local_var_params or
                local_var_params['authorization'] is None):
            raise ApiValueError("Missing the required parameter `authorization` when calling `update_seller_campaigns`")  # noqa: E501
        # verify the required parameter 'campaign_messages' is set
        if ('campaign_messages' not in local_var_params or
                local_var_params['campaign_messages'] is None):
            raise ApiValueError("Missing the required parameter `campaign_messages` when calling `update_seller_campaigns`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in local_var_params:
            header_params['Authorization'] = local_var_params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'campaign_messages' in local_var_params:
            body_params = local_var_params['campaign_messages']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'text/html'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'text/json', 'application/xml', 'text/xml', 'application/x-www-form-urlencoded', 'text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Authorization']  # noqa: E501

        return self.api_client.call_api(
            '/v2/crp/seller-campaigns', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SellerCampaignMessage]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
